window.addEventListener('DOMContentLoaded', function() { // Ловим событие полной загрузки DOM-дерева и только после этого запускаем выполнение скрипта
    let products = document.querySelectorAll('.product'), // Создаем массив продуктов из списка, представленного на странице
        buttons = document.querySelectorAll('button'), // Создаем массив кнопок добавления продуктов в корзину (каждая позиция данного массива соответствует эквивалентной в массиве products)
        openBtn = document.querySelector('.open'); // Присваеваем переменной openBtn значение кнопки "Открыть корзину"

    function createCart() { // Функция для генерации корзины (срабатывает при нажатии на кнопку "Открыть корзину")
        let cart = document.createElement('div'), // Создаем обертку для корзины
            field = document.createElement('div'), // Создаем внутренний контент корзины (список товаров)
            heading = document.createElement('h2'), // Создаем заголовок корзины
            closeBtn = document.createElement('button'); // Создаем кнопку для закрытия корзины

        cart.classList.add('cart'); //Добавляем к оберточному тегу корзины класс .cart
        field.classList.add('cart-field');
        closeBtn.classList.add('close');

        heading.textContent = "В нашей корзине:"; // Присваиваем заголовку контент
        closeBtn.textContent = "Закрыть"; // Присваиваем кнопке закрытия корзины контент

        document.body.appendChild(cart); // Добавляем "обертку корзины" в верстку (т.е. в DOM-дерево) внутрь тега body
        cart.appendChild(heading);
        cart.appendChild(field);
        cart.appendChild(closeBtn);
    }

    createCart();

    let field = document.querySelector('.cart-field'), // Создаем новую переменную field (отметим, что это совершенно другая переменная, отличная от одноименной, т.к. находится в другой зоне видимости)
        cart = document.querySelector('.cart'),
        close = document.querySelector('.close');

    function openCart() { // Функция, которая отвечает за открытие корзины
        cart.style.display = 'block';
    }

    function closeCart() { // Функция, которая отвечает за закрытие корзины
        cart.style.display = 'none';
    }

    openBtn.addEventListener('click', openCart); // Отслеживаем клик по кнопке "Открыть корзину" (с классом open), чтобы вызвать функцию открытия корзины
    close.addEventListener('click', closeCart); // Отслеживаем клик по кнопке "Закрыть" (с классом close), чтобы вызвать функцию закрытия корзины

    /* Далее разработаем следующий алгоритм
    Мы имеем на странице 8 элементов с товарами (массив products). Внутри каждого блока есть кнопка "Купить" (массив buttons как раз содержит в себе эти кнопки), которая должна переместить товар в корзину и запретить заново добавлять его туда с главной страницы. Перемещать товар в корзину мы будем с помощью инструмента клонирования элемента, а затем будем удалять кнопку "Купить" с добавленного элемента. */

    /* Первый сопособ (старый) */

    // for (let i = 0; i < buttons.length; i++) { // создаем цикл for, в котором при каждом прохождении цикла переменная i (которая отвечает за номер элемента в массиве продуктов и в массиве кнопок. Как мы помним - они равны) и завершается когда i достигнет значения длины массива (buttons.length)
    //     buttons[i].addEventListener('click', function() {
    //         let item = products[i].cloneNode(true), // при наступления события клонируем элемент products в переменную item, который соответствует нажатой кнопке "Купить" методом глубокого клонирования (параметр true) - т.е. клонируем элемент со всеми его дочерними элементами.
    //             btn = item.querySelector('button'); // создаем переменную, в которую записываем кнопку "Купить" ИЗ КЛОНИРОВАННОГО элемента products, чтобы затем ее удалить

    //         btn.remove(); // удаляем элемент, который мы только что получили из DOM-дерева методом remove()
    //         field.appendChild(item); // помещаем склонированный элемент (с удаленной кнопкой "Купить") внутрь корзины
    //         products[i].remove(); // удаляем конкретный продукт с главной страницы
    //     });

    // }

    /* Второй способ (современный) */

    /* Второй способ основан на том, что метод querrySelectorAll имеет одну особенность перед другими методами (напрмер selectElementsByClassName, selectElementsByTagName и т.д.), ктороые создают ПСЕВДОмассивы. Псевдомассивы, создаваемые этим методом имеют дополнительным методом (которым также обладают все массивы, не связанные со страницей) - forEach. Именно этот метод позволит нам перебрать все элементы псеводмассива buttons не прибегая к циклам */

    buttons.forEach(function(item, i) { // функция данного метода может принимать в себя 3 элемента. Первый обозначает каждый элемент массива (item). Второй аргумент обозначает индекс перебираемого элемента массива (1,2,3 и т.д. - i). Третий аргумент обозначает весь массив, который мы перебираем (напрмиер array). Может использовать как 1, 2 или 3 аргумента данной функции.
        item.addEventListener('click', function() {
            let item = products[i].cloneNode(true), // при наступления события клонируем элемент products в переменную item, который соответствует нажатой кнопке "Купить" методом глубокого клонирования (параметр true) - т.е. клонируем элемент со всеми его дочерними элементами.
            btn = item.querySelector('button'); // создаем переменную, в которую записываем кнопку "Купить" ИЗ КЛОНИРОВАННОГО элемента products, чтобы затем ее удалить
        
            btn.remove(); // удаляем элемент, который мы только что получили из DOM-дерева методом remove()
            field.appendChild(item); // помещаем склонированный элемент (с удаленной кнопкой "Купить") внутрь корзины
            products[i].remove(); // удаляем конкретный продукт с главной страницы
        });
    });

});

